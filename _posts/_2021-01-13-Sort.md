---

---

## 정렬 알고리즘 개요

정렬이란 특정 데이터를 특정 기준 순서로 나열하는 것을 말한다. 보통 오름차순이나 내림차순이 대부분이다. 정렬 알고리즘을 적용할 경우 `이진 탐색`이 가능해진다. 때문에 정렬 알고리즘은 이진 탐색에 꼭 필요한 전처리 과정이 되는 셈이다.

정렬 알고리즘의 종류는 아주 다양하지만 현재 주로 공부하게 될 것은 선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬이다. 파이썬을 활용해서 알아볼 것이기 때문에 이에 관련된 유용한 라이브러리도 소개하도록 하겠다.

알고리즘 개론책 대부분은 정렬을 가장 먼저 소개한다. 일반적인 문제해결에서 적절하게 정렬을 공식처럼 사용하기 때문에 상황에 맞는 정렬 알고리즘을 사용하는 것은 아주 중요하다.

지금 부터 알아볼 기본 예제에서는 아래와 같은 카드 순서를 바탕으로 정렬한다.


```python
list_ex = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]
```

사람의 눈으로 보았을 때는 그저 0 부터 9까지의 숫자를 순서대로 직관적으로 정렬하면 되지만, 컴퓨터는 직관이없기 때문에 모든 처리과정을 명시하여야한다.

보통 오름차순으로 먼저 정렬하고 내림차순은 오름차순을 반대로 뒤집어서 적용하는 방법을 사용한다. 파이썬에서는 reverse를 사용하여 O(N)의 복잡도로 리스트를 뒤집을 수 있다.

## 선택정렬

**코드**
```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
    min_index = i # 가장 작은 원소의 인덱스
    for j in range(i + 1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
    array[i], array[min_index] = array[min_index], array[i] # swap

print(array) 

```

**출력**
```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

선택 정렬은 가장 떠오르기 쉬운 정렬 방법으로 왼쪽에서 부터 순서대로 가장 작은 수를 찾아서 swap 하는 방법이다.

구동방식은 간단하다. 먼저 가장 왼쪽에 즉, 첫번째 놓을 카드를 찾는다. 가장 작은 수인 0이 된다. 그리고 그 다음(두 번째) 놓을 다음 작은수를 찾는다. 여기서는 1이 온다. 이런식으로 n - 1 번 반복하면 모든 정렬이 완료된다.

여기서 swap 이라고 주석되어있는 부분은 파이썬에서 swap 하는 방법인데 다른 언어보다 쉽게 swap이 가능하다.

**코드**
```python 
array = [2, 4]
array[0], array[1] = array[1], array[0]

print(array)

```

**출력**
```python
[4, 2]
```

### 선택 정렬 시간 복잡도 계산
선택 정렬은 N - 1 번 반복해서 작은 수를 계속해서 찾는다. 비교연산도 동일하게 필요하다. 위 코드에서는 `N + (N - 1) + (N - 2) + ... + 2` 연산 횟수가 소모되며 근사치로는 `N * (N + 1)`번의 연산이 수행될 수 있다. 즉 `O(N²)`의 시간 복잡도 계산을 할 수 있다. 이는 선택 정렬을 하는 데이터의 개수가 10,000개 이상 이면 매우 속도면에서 성능이 떨어진다. 속도 순서는 `선택 정렬 > 퀵 정렬 > 기본 정렬 라이브러리` 순 이다.

## 삽입 정렬 (insertion sort)

- 데이터가 어느정도 정렬되어 있을 경우 효율적
- 삽입이 필요할 때만 위치를 바꿈
- 선택 정렬 보다 효율적

**코드**
```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(1, len(array)):  # 1번 인덱스 부터
    for j in range(i, 0, -1):
        if array[j] < array[j - 1]:
            array[j], array[j - 1] = array[j - 1], array[j]
        else:
            break

print(array)

```

**출력**
```python
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

### 삽입정렬 시간복잡도 계산
삽입정렬의 시간복잡도 계산을 해보면 마찬가지로 `O(N²)`의 시간 복잡도를 구할 수 있다. 직관적으로는 for문이 2중으로 중첩되어 있기 때문에 그렇다. 다음에는 더 빠른 퀵 정렬 말그대로 빠른 정렬을 알아볼건데, 사실 정렬이 잘 되어있는 상태에서는 삽입 정렬이 퀵 정렬보다 빠를 때가 많다.

## 퀵 정렬
퀵 정렬은 가장 많이 사용되고 있는 정렬 알고리즘으로 이것 보다 더 빠른 알고리즘은 별로 없으나 굳이 꼽자면 `병합 정렬`이 있다. 이는 프로그래밍 자체 내부 정렬 라이브러리에 근본이 되는 알고리즘이다.

- 기준 데이터를 설정. 그 기준 보다 큰 데이터 및 작은 데이터 위치를 바꿈

이는 좀 복잡할 수 있지만 병합 정렬이나 힙 정렬 보다는 비교적 쉽게 작성할 수 있다.

퀵 정렬에서는 피벗이라는 개념이 사용된다. 기준이 되는 수를 가리키는 것이 피벗으로 이 기준에 따라서도 또 다시 퀵정렬이 구분될 수 있다. 이 글에서는 호어 분할 (Hoare Partition) 방식을 기준으로 알아보자.

**호어 분할 기준**

- 리스트 첫 번째 데이터를 피벗으로 삼는다.

피벗을 설정했다면, 왼쪽 부터 피벗 보다 **큰** 데이터를 찾는다. 오른쪽(리스트 끝)에서 부터 피벗보다 **작은** 데이터를 찾는다. 그런 다음에 **큰 데이터**와 **작은 데이터**의 위치를 **교환**한다. 그러다가 서로 교차하는 경우 **작은 데이터**와 **피벗**의 위치를 서로 바꾼다. 그러면 피벗 기준으로 왼쪽은 작은 데이터 오른쪽은 큰 데이터가 위치하게된다. 이 과정을 분할 이라고 한다. (또는 파티션)

그 이후에는 파티션된 리스트에 대해서 각각 동일 방식으로 피벗을 설정한뒤 정렬을 하면 결국 모든 데이터가 정렬된다.

**코드**
```python
array = [5,7,9,0,3,1,6,2,4,8]

def quick_sort(array, start, end):
    if start >= end: # 원소가 1개 인 경우 탈출
        return
    pivot = start # 피벗은 첫번 째 원소 기준
    left = start + 1
    right = end
    while left <= right:
        # 피벗 보다 큰 데이터 찾을 때 까지 반복
        while left <= end and array[left] <= array[pivot]:
            left += 1
        # 피벗 보다 작은 데이터 찾을 때 까지 반복
        while  start < right  and  array[right] >= array[pivot] :
            right -= 1

        if left > right: # 피벗이 엇갈린 경우, 파티션 후 loop 중지
            array[right], array[pivot] = array[pivot], array[right]
        else: # 엇갈리지 않은 경우
            array[left], array[right] = array[right], array[left]
    
    quick_sort(array, start, right - 1)
    quick_sort(array, right + 1, end)

quick_sort(array, 0, len(array) - 1)
print(array)

```

**출력**
```python
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

**pythonic 하게 작성한 퀵 정렬 코드**
```python
array = [5,7,9,0,3,1,6,2,4,8]

def quick_sort(array):
    if len(array) <= 1:
        return array

    pivot = array[0]
    tail = array[1:]

    left_side = [x for x in tail if x <= pivot]
    right_side = [x for x in tail if x > pivot]

    return quick_sort(left_side) + [pivot] + quick_sort(right_side)

print(quick_sort(array))
```

좀 더 파이써닉하게 만든 코드는 가장 왼쪽 피벗을 고르고 왼쪽, 오른쪽을 피벗 기준으로 리스트로 만들고 left, right를 재귀적으로 또 퀵소트하는 방법이다.
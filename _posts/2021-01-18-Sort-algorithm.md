---
title: "선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬 한번에 알고가기 (With 파이썬)"
excerpt: "정렬 알고리즘 쉬운 정리 (선택, 삽입, 퀵, 계수 정렬)"

categories:
    - Algorithm
    - Python
tags:
    - Algorithm
    - Python
    - BFS
last_modified_at: 2021-01-18T21:24:00+09:00

---

## 1. 정렬 알고리즘 개요

정렬이란 특정 데이터를 특정 기준 순서로 나열하는 것을 말한다. 보통 오름차순이나 내림차순이 대부분이다. 정렬 알고리즘을 적용할 경우 `이진 탐색`이 가능해진다. 때문에 정렬 알고리즘은 이진 탐색에 꼭 필요한 전처리 과정이 되는 셈이다.

정렬 알고리즘의 종류는 아주 다양하지만 현재 주로 공부하게 될 것은 선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬이다. 파이썬을 활용해서 알아볼 것이기 때문에 이에 관련된 유용한 라이브러리도 소개하도록 하겠다.

알고리즘 개론책 대부분은 정렬을 가장 먼저 소개한다. 일반적인 문제해결에서 적절하게 정렬을 공식처럼 사용하기 때문에 상황에 맞는 정렬 알고리즘을 사용하는 것은 아주 중요하다.

지금 부터 알아볼 기본 예제에서는 아래와 같은 카드 순서를 바탕으로 정렬한다.


```python
list_ex = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]
```

사람의 눈으로 보았을 때는 그저 0 부터 9까지의 숫자를 순서대로 직관적으로 정렬하면 되지만, 컴퓨터는 직관이없기 때문에 모든 처리과정을 명시하여야한다.

보통 오름차순으로 먼저 정렬하고 내림차순은 오름차순을 반대로 뒤집어서 적용하는 방법을 사용한다. 파이썬에서는 reverse를 사용하여 O(N)의 복잡도로 리스트를 뒤집을 수 있다.

## 2. 선택정렬

**코드**
```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
    min_index = i # 가장 작은 원소의 인덱스
    for j in range(i + 1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
    array[i], array[min_index] = array[min_index], array[i] # swap

print(array) 

```

**출력**
```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

선택 정렬은 가장 떠오르기 쉬운 정렬 방법으로 왼쪽에서 부터 순서대로 가장 작은 수를 찾아서 swap 하는 방법이다.

구동방식은 간단하다. 먼저 가장 왼쪽에 즉, 첫번째 놓을 카드를 찾는다. 가장 작은 수인 0이 된다. 그리고 그 다음(두 번째) 놓을 다음 작은수를 찾는다. 여기서는 1이 온다. 이런식으로 n - 1 번 반복하면 모든 정렬이 완료된다.

여기서 swap 이라고 주석되어있는 부분은 파이썬에서 swap 하는 방법인데 다른 언어보다 쉽게 swap이 가능하다.

**코드**
```python 
array = [2, 4]
array[0], array[1] = array[1], array[0]

print(array)

```

**출력**
```python
[4, 2]
```

### 2.1. 선택 정렬 시간 복잡도 계산
선택 정렬은 N - 1 번 반복해서 작은 수를 계속해서 찾는다. 비교연산도 동일하게 필요하다. 위 코드에서는 `N + (N - 1) + (N - 2) + ... + 2` 연산 횟수가 소모되며 근사치로는 `N * (N + 1)`번의 연산이 수행될 수 있다. 즉 `O(N²)`의 시간 복잡도 계산을 할 수 있다. 이는 선택 정렬을 하는 데이터의 개수가 10,000개 이상 이면 매우 속도면에서 성능이 떨어진다. 속도 순서는 `선택 정렬 > 퀵 정렬 > 기본 정렬 라이브러리` 순 이다.

## 3. 삽입 정렬 (insertion sort)

- 데이터가 어느정도 정렬되어 있을 경우 효율적
- 삽입이 필요할 때만 위치를 바꿈
- 선택 정렬 보다 효율적

**코드**
```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(1, len(array)):  # 1번 인덱스 부터
    for j in range(i, 0, -1):
        if array[j] < array[j - 1]:
            array[j], array[j - 1] = array[j - 1], array[j]
        else:
            break

print(array)

```

**출력**
```python
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

### 3.1. 삽입정렬 시간복잡도 계산
삽입정렬의 시간복잡도 계산을 해보면 마찬가지로 `O(N²)`의 시간 복잡도를 구할 수 있다. 직관적으로는 for문이 2중으로 중첩되어 있기 때문에 그렇다. 다음에는 더 빠른 퀵 정렬 말그대로 빠른 정렬을 알아볼건데, 사실 정렬이 잘 되어있는 상태에서는 삽입 정렬이 퀵 정렬보다 빠를 때가 많다.

## 4. 퀵 정렬
퀵 정렬은 가장 많이 사용되고 있는 정렬 알고리즘으로 이것 보다 더 빠른 알고리즘은 별로 없으나 굳이 꼽자면 `병합 정렬`이 있다. 이는 프로그래밍 자체 내부 정렬 라이브러리에 근본이 되는 알고리즘이다.

- 기준 데이터를 설정. 그 기준 보다 큰 데이터 및 작은 데이터 위치를 바꿈

이는 좀 복잡할 수 있지만 병합 정렬이나 힙 정렬 보다는 비교적 쉽게 작성할 수 있다.

퀵 정렬에서는 피벗이라는 개념이 사용된다. 기준이 되는 수를 가리키는 것이 피벗으로 이 기준에 따라서도 또 다시 퀵정렬이 구분될 수 있다. 이 글에서는 호어 분할 (Hoare Partition) 방식을 기준으로 알아보자.

**호어 분할 기준**

- 리스트 첫 번째 데이터를 피벗으로 삼는다.

피벗을 설정했다면, 왼쪽 부터 피벗 보다 **큰** 데이터를 찾는다. 오른쪽(리스트 끝)에서 부터 피벗보다 **작은** 데이터를 찾는다. 그런 다음에 **큰 데이터**와 **작은 데이터**의 위치를 **교환**한다. 그러다가 서로 교차하는 경우 **작은 데이터**와 **피벗**의 위치를 서로 바꾼다. 그러면 피벗 기준으로 왼쪽은 작은 데이터 오른쪽은 큰 데이터가 위치하게된다. 이 과정을 분할 이라고 한다. (또는 파티션)

그 이후에는 파티션된 리스트에 대해서 각각 동일 방식으로 피벗을 설정한뒤 정렬을 하면 결국 모든 데이터가 정렬된다.

**코드**
```python
array = [5,7,9,0,3,1,6,2,4,8]

def quick_sort(array, start, end):
    if start >= end: # 원소가 1개 인 경우 탈출
        return
    pivot = start # 피벗은 첫번 째 원소 기준
    left = start + 1
    right = end
    while left <= right:
        # 피벗 보다 큰 데이터 찾을 때 까지 반복
        while left <= end and array[left] <= array[pivot]:
            left += 1
        # 피벗 보다 작은 데이터 찾을 때 까지 반복
        while  start < right  and  array[right] >= array[pivot] :
            right -= 1

        if left > right: # 피벗이 엇갈린 경우, 파티션 후 loop 중지
            array[right], array[pivot] = array[pivot], array[right]
        else: # 엇갈리지 않은 경우
            array[left], array[right] = array[right], array[left]
    
    quick_sort(array, start, right - 1)
    quick_sort(array, right + 1, end)

quick_sort(array, 0, len(array) - 1)
print(array)

```

**출력**
```python
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

**pythonic 하게 작성한 퀵 정렬 코드**
```python
array = [5,7,9,0,3,1,6,2,4,8]

def quick_sort(array):
    if len(array) <= 1:
        return array

    pivot = array[0]
    tail = array[1:]

    left_side = [x for x in tail if x <= pivot]
    right_side = [x for x in tail if x > pivot]

    return quick_sort(left_side) + [pivot] + quick_sort(right_side)

print(quick_sort(array))
```

좀 더 파이써닉하게 만든 코드는 가장 왼쪽 피벗을 고르고 왼쪽, 오른쪽을 피벗 기준으로 리스트로 만들고 left, right를 재귀적으로 또 퀵소트하는 방법이다.

### 4.1. 퀵 정렬 시간 복잡도 계산

선택 정렬과 삽입 정렬은 최악의 경우에도 항상 O(N²)을 보장 하며, 퀵정렬은 평균적으로는 O(NlogN)을 갖는다. 선택 정렬 및 삽입 정렬 보다 훨신 빠른 편에 속하는 것이다.

직관적으로 로그를 가지는 복잡도이기 때문에 데이터가 많이 늘어날 수록 확연하게 다른 알고리즘 보다 빠르게 동작할 수 있다.

그러나 최악의 경우에는 퀵정렬 또한 O(N²)의 시간 복잡도를 갖게되는데 바로 이미 데이터가 정렬이 되어있는 경우가 그러하다. 아이러니하게도 삽입정렬과 정반대의 원인으로 시간 복잡도가 갈린다. (삽입은 정렬되어있는 경우 빠르게 동작) 그래서 보통 C++ 라이브러리 같은 경우 피벗을 고를 때 추가 로직을 구현해두어 O(NlogN)이 되는 것을 보장한다.

## 5. 계수 정렬 (Count sort)

계수 정렬은 아주 빠른데, 특정 상황이 정해진 경우에만 사용할 수 있다. 시간 복잡도는 최악의 경우에도 O(N + K)를 보장한다. (데이터 개수가 N개, 데이터 중 최대값이 K) 이런 식으로 데이터의 크기와 범위가 제한되어 있는 경우 그리고 정수 형태로 표현될 수 있는 경우에 한에서만 사용할 수 있다. 일반적으로 가장큰 값과 작은 값의 차이가 1,000,000을 넘지 않는 경우에 효과적이다.

큰 값과 작은 값의 차이 크기 만큼의 배열을 미리 선언하고 모든 값을 방문하면서 해당하는 계수에 대한 부분의 배열에 접근해서 카운트를 늘리는 아주 단순한 방식의 정렬 방법이다.

**코드**

```python
array = [7,5,9,0,3,1,6,2,9,1,4,8,0,5,2]
count = [0] * (max(array) + 1)

for i in range(len(array)):
    count[array[i]] += 1

for i in range(len(count)):
    for j in range(count[i]):
        print(i, end=' ')


```

**결과**

```python
0 0 1 1 2 2 3 4 5 5 6 7 8 9 9 
```

### 5.1. 계수 정렬 시간 복잡도 계산

모든 데이터가 양의 정수이고 N개, 최대 값의 크기가 K일 경우 시간 복잡도는 O(N + K)가 된다. 

## 6. 마치며

이로써 정렬 알고리즘의 개요로 삽입 정렬, 선택 정렬, 퀵 정렬, 계수 정렬에 대해서 모두 알아보았다. 각기 장단점이 있으며 특히 마지막 계수 정렬은 데이터가 한정되있고 중복된다면 가장 빠른 해답을 줄 수 있다. 그러나 웬만해서는 퀵정렬이 나머지 정렬보다 빠른 속도를 낼 수 있을 것이다.

다음 글에서는 파이썬에 기본적으로 내장되어있는 정렬 라이브러리의 강력함과 그 사용 방법을 알아보도록 하겠다.

**관련 글**
- [DFS 와 BFS 란? 탐색과 자료구조 알고리즘 이해하기 #1]({{ site.url }}/algorithm/python/Search-Data-Structure-DFS-BFS/){: target="_blank"}
- [DFS 와 BFS 란? 탐색 알고리즘 구현 및 이해하기 #2]({{ site.url }}/algorithm/python/DFS-BFS-알고리즘이란/){: target="_blank"}

**Recommend:**  
- [알고리즘 코딩테스트 자주 쓰는 파이썬 코드 : 입출력]({{ site.url }}/python/algorithm/python-input-output-tips/){: target="_blank"}
- [깃허브(GitHub) 블로그 시작하기 Jekyll로 쉽게 만드는 방법]({{ site.url }}/blog/How-to-Create-a-GitHub-Blog/){: target="_blank"}    
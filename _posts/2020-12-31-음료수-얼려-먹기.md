---
title: "DFS 기본 문제 : 음료수 얼려 먹기 (파이썬 풀이)"
excerpt: "DFS 기본 문제인 음료수 얼려 먹기를 파이썬으로 풀이합니다."

categories:
    - Algorithm
    - Python
tags:
    - Algorithm
    - Python
    - DFS
last_modified_at: 2020-12-29T21:31:00+09:00

---

## 1. 문제 설명

N * M 크기의 얼음 틀이 있다. 구멍이 뚫려 있는 부분은 0 이고 칸막이가 존재하는 부분은 1이다. 즉, 0으로 연결된 부분이 얼음 한 덩이가 얼려져 나오는 것이다. 구멍이 뚫려 있는 부분 끼리 상, 하, 좌, 우로 붙어 있는 경우가 서로 연결된 경우가 된다. 이때 얼음 틀의 모양이 주어졌을 때 생성되는 총 아이스크림의 개수를 구하는 프로그램을 작성하시오.

![DFS 예시 이미지](/assets/images/DFS_example.png)

### 1.1. 예시 1

예시로 아래와 같은 얼음판의 경우를 보자.

```
00110
00011
11111
00000
```

위와 같은 경우에는 아이스크림이 총 3개가 생성되는 것이다.

### 1.2. 입력 조건

- 첫 번째 줄에 얼음 틀의 세로와 가로길이 N, M이 주어진다.  (`1 <= N, M <= 1,000`)
- 두 번째 줄부터 N + 1 번째 줄까지 얼음 틀의 형태가 주어진다.
- 이때 구멍이 뚫려있는 부분은 0, 아닌 부분은 1이다.

### 1.3. 출력 조건

- 한 번에 만들 수 있는 아이스크림의 개수를 출력한다.

### 1.4. 예시 2


**입력**
```
15 14
00000111100000
11111101111110
11011101101110
11011101100000
11011111111111
11011111111100
11000000011111
01111111111111
00000000011111
01111111111000
00011111111000
11111111110011
11100011111111
11100011111111
```

**출력**
```
8
```

## 2. 문제 해설

해당 문제는 DFS를 이용해서 해결할 수 있다. 얼음 칸이 상하좌우로 연결 될 수 있으므로 이를 그래프 형태로 모델링하여 풀면 되는 것이다. 이 문제에서는 0 으로 묶인 그래프를 만들면 되는 것이다.

1. 특정 지점의 주변 상, 하, 좌, 우를 모두 살펴보고 주변에 값이 0 이고 방문하지 않은 곳이 있다면 그 칸을 방문한다.
2. 방문한 곳에서 다시 상, 하, 좌, 우를 살펴보면 연결된 모든 곳을 방문하게 된다.
3. 1~2를 반복하면서 방문하지 않은 지점 수를 카운트

## 3. 구현 코드

구현 코드는 아래와 같습니다.

```python
n, m = map(int, input().split())

graph = []
for i in range(n):
    graph.append(list(map(int, input())))  # cf. str은 iterable


def dfs(x, y):
    # 범위 검사
    if x <= -1 or x >= n or y <= -1 or y >= m:
        return False
    # 현재 노드를 아직 방문하지 않았다면
    if graph[x][y] == 0:
        graph[x][y] = 1
        dfs(x-1, y)
        dfs(x, y-1)
        dfs(x+1, y)
        dfs(x, y+1)
        return True
    return False


result = 0
for i in range(n):
    for j in range(m):
        if dfs(i, j) == True:
            result += 1

print(result)

```

구현 코드 부분에서 처음에 이해가 되지 않았던 부분은 `list(map(int, input()))`이 부분 이었는데요? map에 두 번째 인자에 input()으로 `00000111100000`을 받는데 어떻게 이게 리스트 형식으로 쪼개지는지 이해가 잘 안되어 찾아보니 str(문자열) 형식이 애초에 iterable 한 형식 이기 때문에 map을 적용하면 문자(char) 단위로 돌면서 적용이 되어 리스트 형식으로 쪼개질 수 있던 것 이었습니다.

나머지 구현 코드는 이해하는데 큰 어려움이 없었습니다. `dfs`함수가 방문하지 않은 (값이 0인) 노드를 방문하며 연결된 모든 부분을 방문처리하며 `result += 1`로 카운트 하면서 큰 덩어리 하나 하나를 세는 것이죠.

위에 예시 입력을 주었을 때 정답인 `8`값을 정상적으로 출력하는 것을 확인할 수 있습니다.

비교적 난이도가 쉬운 편에 속해서 이해하는데 어려움이 없었지만, 해당 코드를 안보고 짤 수 있을 정도가 되도록 확실하게 이해하고 넘어가야겠습니다.

**관련 글**
- [DFS 와 BFS 란? 탐색 알고리즘 구현 및 이해하기 #2]({{ site.url }}/algorithm/python/DFS-BFS-알고리즘이란/){: target="_blank"}
- [DFS 와 BFS 란? 탐색과 자료구조 알고리즘 이해하기 #1]({{ site.url }}/algorithm/python/Search-Data-Structure-DFS-BFS/){: target="_blank"}

**Recommend:**  
- [백준 1003번: 피보나치함수 파이썬 문제풀이 (BOJ 1003)]({{ site.url }}/algorithm/python/BOJ-1003/){: target="_blank"}
- [알고리즘 코딩테스트 자주 쓰는 파이썬 코드 : 입출력]({{ site.url }}/python/algorithm/python-input-output-tips/){: target="_blank"}
- [깃허브(GitHub) 블로그 시작하기 Jekyll로 쉽게 만드는 방법]({{ site.url }}/blog/How-to-Create-a-GitHub-Blog/){: target="_blank"}    